/*
 * Copyright 2024, gRPC Authors All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

internal import SwiftProtobuf

extension ErrorDetails {
  /// Describes the cause of the error with structured details.
  ///
  /// Example of an error when contacting the "pubsub.googleapis.com" API when it
  /// is not enabled:
  ///
  /// ```
  /// { "reason": "API_DISABLED"
  ///   "domain": "googleapis.com"
  ///   "metadata": {
  ///     "resource": "projects/123",
  ///     "service": "pubsub.googleapis.com"
  ///   }
  /// }
  /// ```
  ///
  /// This response indicates that the pubsub.googleapis.com API is not enabled.
  ///
  /// Example of an error that is returned when attempting to create a Spanner
  /// instance in a region that is out of stock:
  ///
  /// ```
  /// { "reason": "STOCKOUT"
  ///   "domain": "spanner.googleapis.com",
  ///   "metadata": {
  ///     "availableRegions": "us-central1,us-east2"
  ///   }
  /// }
  /// ```
  public struct ErrorInfo: Sendable, Hashable, GoogleProtobufAnyPackable, ProtobufBacked {
    var storage: Google_Rpc_ErrorInfo
    // See https://protobuf.dev/programming-guides/proto3/#any
    static var typeURL: String { "type.googleapis.com/google.rpc.ErrorInfo" }

    init(storage: Google_Rpc_ErrorInfo) {
      self.storage = storage
    }

    /// The reason of the error.
    ///
    /// This is a constant value that identifies the proximate cause of the error. Error reasons
    /// are unique within a particular domain of errors. This should be at most 63 characters and
    /// match a regular expression of `[A-Z][A-Z0-9_]+[A-Z0-9]`, which represents
    /// 'UPPER\_SNAKE\_CASE'.
    public var reason: String {
      get { self.storage.reason }
      set { self.storage.reason = newValue }
    }

    /// The logical grouping to which the "reason" belongs.
    ///
    /// The error domain is typically the registered service name of the tool or product that
    /// generates the error. Example: "pubsub.googleapis.com". If the error is generated by some
    /// common infrastructure, the error domain must be a globally unique value that identifies
    /// the infrastructure. For Google API infrastructure, the error domain is "googleapis.com".
    public var domain: String {
      get { self.storage.domain }
      set { self.storage.domain = newValue }
    }

    /// Additional structured details about this error.
    ///
    /// Keys should match `[a-zA-Z0-9-_]` and be limited to 64 characters in length. When
    /// identifying the current value of an exceeded limit, the units should be contained in the
    /// key, not the value.  For example, rather than `{"instanceLimit": "100/request"}`, should be
    /// returned as, `{"instanceLimitPerRequest": "100"}``, if the client exceeds the number of
    /// instances that can be created in a single (batch) request.
    public var metadata: [String: String] {
      get { self.storage.metadata }
      set { self.storage.metadata = newValue }
    }

    public init(reason: String, domain: String, metadata: [String: String] = [:]) {
      self.storage = .with {
        $0.reason = reason
        $0.domain = domain
        $0.metadata = metadata
      }
    }
  }

  /// Describes when the clients can retry a failed request. Clients could ignore
  /// the recommendation here or retry when this information is missing from error
  /// responses.
  ///
  /// It's always recommended that clients should use exponential backoff when
  /// retrying.
  ///
  /// Clients should wait until `retry_delay` amount of time has passed since
  /// receiving the error response before retrying.  If retrying requests also
  /// fail, clients should use an exponential backoff scheme to gradually increase
  /// the delay between retries based on `retry_delay`, until either a maximum
  /// number of retries have been reached or a maximum retry delay cap has been
  /// reached.
  public struct RetryInfo: Sendable, Hashable, GoogleProtobufAnyPackable {
    // See https://protobuf.dev/programming-guides/proto3/#any
    internal static var typeURL: String { "type.googleapis.com/google.rpc.RetryInfo" }

    internal func pack() throws -> Google_Protobuf_Any {
      let duration = Google_Rpc_RetryInfo.with {
        $0.retryDelay = .with {
          $0.seconds = self.delay.components.seconds
          $0.nanos = Int32(self.delay.components.attoseconds / 1_000_000_000)
        }
      }

      return try .with {
        $0.typeURL = Self.typeURL
        $0.value = try duration.serializedBytes()
      }
    }

    /// Clients should wait at least this long between retrying the same request.
    public var delay: Duration

    public init(delay: Duration) {
      self.delay = delay
    }

    init?(unpacking any: Google_Protobuf_Any) throws {
      guard let info = try any.unpack(Google_Rpc_RetryInfo.self) else { return nil }
      self.delay = Duration(
        secondsComponent: info.retryDelay.seconds,
        attosecondsComponent: Int64(info.retryDelay.nanos) * 1_000_000_000
      )
    }
  }

  /// Describes additional debugging info.
  public struct DebugInfo: Sendable, Hashable, GoogleProtobufAnyPackable, ProtobufBacked {
    var storage: Google_Rpc_DebugInfo
    // See https://protobuf.dev/programming-guides/proto3/#any
    static var typeURL: String { "type.googleapis.com/google.rpc.DebugInfo" }

    init(storage: Google_Rpc_DebugInfo) {
      self.storage = storage
    }

    /// The stack trace entries indicating where the error occurred.
    public var stack: [String] {
      get { self.storage.stackEntries }
      set { self.storage.stackEntries = newValue }
    }

    /// Additional debugging information provided by the server.
    public var detail: String {
      get { self.storage.detail }
      set { self.storage.detail = newValue }
    }

    public init(stack: [String], detail: String) {
      self.storage = .with {
        $0.stackEntries = stack
        $0.detail = detail
      }
    }
  }

  /// Describes how a quota check failed.
  ///
  /// For example if a daily limit was exceeded for the calling project,
  /// a service could respond with a QuotaFailure detail containing the project
  /// id and the description of the quota limit that was exceeded.  If the
  /// calling project hasn't enabled the service in the developer console, then
  /// a service could respond with the project id and set `service_disabled`
  /// to true.
  ///
  /// Also see RetryInfo and Help types for other details about handling a
  /// quota failure.
  public struct QuotaFailure: Sendable, Hashable, GoogleProtobufAnyPackable {
    /// A message type used to describe a single quota violation. For example, a
    /// daily quota or a custom quota that was exceeded.
    public struct Violation: Sendable, Hashable {
      /// The subject on which the quota check failed.
      ///
      /// For example, "clientip:<ip address of client>" or "project:<Google developer project id>".
      public var subject: String

      /// A description of how the quota check failed.
      ///
      /// Clients can use this description to find more about the quota configuration in the
      /// service's public documentation, or find the relevant quota limit to adjust through
      /// developer console.
      ///
      /// For example: "Service disabled" or "Daily Limit for read operations
      /// exceeded".
      public var violationDescription: String

      public init(subject: String, description: String) {
        self.subject = subject
        self.violationDescription = description
      }

      init(_ storage: Google_Rpc_QuotaFailure.Violation) {
        self.subject = storage.subject
        self.violationDescription = storage.description_p
      }
    }

    // See https://protobuf.dev/programming-guides/proto3/#any
    internal static var typeURL: String { "type.googleapis.com/google.rpc.QuotaFailure" }

    internal func pack() throws -> Google_Protobuf_Any {
      let message = Google_Rpc_QuotaFailure.with {
        $0.violations = self.violations.map { violation in
          .with {
            $0.subject = violation.subject
            $0.description_p = violation.violationDescription
          }
        }
      }

      return try .with {
        // See https://protobuf.dev/programming-guides/proto3/#any
        $0.typeURL = Self.typeURL
        $0.value = try message.serializedBytes()
      }
    }

    /// Describes all quota violations.
    public var violations: [Violation]

    public init(violations: [Violation]) {
      self.violations = violations
    }

    init?(unpacking any: Google_Protobuf_Any) throws {
      guard let message = try any.unpack(Google_Rpc_QuotaFailure.self) else { return nil }
      self.violations = message.violations.map { Violation($0) }
    }
  }

  /// Describes what preconditions have failed.
  ///
  /// For example, if an RPC failed because it required the Terms of Service to be
  /// acknowledged, it could list the terms of service violation in the
  /// PreconditionFailure message.
  public struct PreconditionFailure: Sendable, Hashable, GoogleProtobufAnyPackable {
    /// A message type used to describe a single precondition failure.
    public struct Violation: Sendable, Hashable {
      /// The type of PreconditionFailure.
      ///
      /// We recommend using a service-specific enum type to define the supported precondition
      /// violation subjects. For example, "TOS" for "Terms of Service violation".
      public var type: String

      /// The subject, relative to the type, that failed.
      ///
      /// For example, "google.com/cloud" relative to the "TOS" type would indicate
      /// which terms of service is being referenced.
      public var subject: String

      /// A description of how the precondition failed. Developers can use this
      /// description to understand how to fix the failure.
      ///
      /// For example: "Terms of service not accepted".
      public var violationDescription: String

      public init(type: String, subject: String, description: String) {
        self.type = type
        self.subject = subject
        self.violationDescription = description
      }

      init(_ storage: Google_Rpc_PreconditionFailure.Violation) {
        self.type = storage.type
        self.subject = storage.subject
        self.violationDescription = storage.description_p
      }
    }

    // See https://protobuf.dev/programming-guides/proto3/#any
    internal static var typeURL: String { "type.googleapis.com/google.rpc.PreconditionFailure" }

    internal func pack() throws -> Google_Protobuf_Any {
      let message = Google_Rpc_PreconditionFailure.with {
        $0.violations = self.violations.map { violation in
          .with {
            $0.type = violation.type
            $0.subject = violation.subject
            $0.description_p = violation.violationDescription
          }
        }
      }

      return try .with {
        $0.typeURL = Self.typeURL
        $0.value = try message.serializedBytes()
      }
    }

    /// Describes all precondition violations.
    public var violations: [Violation]

    public init(violations: [Violation]) {
      self.violations = violations
    }

    init?(unpacking any: Google_Protobuf_Any) throws {
      guard let message = try any.unpack(Google_Rpc_PreconditionFailure.self) else { return nil }
      self.violations = message.violations.map { Violation($0) }
    }
  }

  /// Describes violations in a client request. This error type focuses on the
  /// syntactic aspects of the request.
  public struct BadRequest: Sendable, Hashable, GoogleProtobufAnyPackable {
    /// A message type used to describe a single bad request field.
    public struct FieldViolation: Sendable, Hashable {
      /// A path that leads to a field in the request body. The value will be a
      /// sequence of dot-separated identifiers that identify a protocol buffer
      /// field.
      ///
      /// Consider the following:
      ///
      ///     message CreateContactRequest {
      ///       message EmailAddress {
      ///         enum Type {
      ///           TYPE_UNSPECIFIED = 0;
      ///           HOME = 1;
      ///           WORK = 2;
      ///         }
      ///
      ///         optional string email = 1;
      ///         repeated EmailType type = 2;
      ///       }
      ///
      ///       string full_name = 1;
      ///       repeated EmailAddress email_addresses = 2;
      ///     }
      ///
      /// In this example, in proto `field` could take one of the following values:
      ///
      /// * `full_name` for a violation in the `full_name` value
      /// * `email_addresses[1].email` for a violation in the `email` field of the
      ///   first `email_addresses` message
      /// * `email_addresses[3].type[2]` for a violation in the second `type`
      ///   value in the third `email_addresses` message.
      ///
      /// In JSON, the same values are represented as:
      ///
      /// * `fullName` for a violation in the `fullName` value
      /// * `emailAddresses[1].email` for a violation in the `email` field of the
      ///   first `emailAddresses` message
      /// * `emailAddresses[3].type[2]` for a violation in the second `type`
      ///   value in the third `emailAddresses` message.
      public var field: String

      /// A description of why the request element is bad.
      public var violationDescription: String

      public init(field: String, description: String) {
        self.field = field
        self.violationDescription = description
      }

      init(_ storage: Google_Rpc_BadRequest.FieldViolation) {
        self.field = storage.field
        self.violationDescription = storage.description_p
      }
    }

    // See https://protobuf.dev/programming-guides/proto3/#any
    internal static var typeURL: String { "type.googleapis.com/google.rpc.BadRequest" }

    internal func pack() throws -> Google_Protobuf_Any {
      let message = Google_Rpc_BadRequest.with {
        $0.fieldViolations = self.violations.map { violation in
          .with {
            $0.field = violation.field
            $0.description_p = violation.violationDescription
          }
        }
      }

      return try .with {
        $0.typeURL = Self.typeURL
        $0.value = try message.serializedBytes()
      }
    }

    init?(unpacking any: Google_Protobuf_Any) throws {
      guard let message = try any.unpack(Google_Rpc_BadRequest.self) else { return nil }
      self.violations = message.fieldViolations.map { FieldViolation($0) }
    }

    /// Describes all violations in a client request.
    public var violations: [FieldViolation]

    public init(violations: [FieldViolation]) {
      self.violations = violations
    }

  }

  /// Contains metadata about the request that clients can attach when filing a bug
  /// or providing other forms of feedback.
  public struct RequestInfo: Sendable, Hashable, GoogleProtobufAnyPackable, ProtobufBacked {
    var storage: Google_Rpc_RequestInfo
    // See https://protobuf.dev/programming-guides/proto3/#any
    static var typeURL: String { "type.googleapis.com/google.rpc.RequestInfo" }

    init(storage: Google_Rpc_RequestInfo) {
      self.storage = storage
    }

    /// An opaque string that should only be interpreted by the service generating
    /// it. For example, it can be used to identify requests in the service's logs.
    public var requestID: String {
      get { self.storage.requestID }
      set { self.storage.requestID = newValue }
    }

    /// Any data that was used to serve this request. For example, an encrypted
    /// stack trace that can be sent back to the service provider for debugging.
    public var servingData: String {
      get { self.storage.servingData }
      set { self.storage.servingData = newValue }
    }

    public init(requestID: String, servingData: String) {
      self.storage = .with {
        $0.requestID = requestID
        $0.servingData = servingData
      }
    }
  }

  /// Describes the resource that is being accessed.
  public struct ResourceInfo: Sendable, Hashable, GoogleProtobufAnyPackable, ProtobufBacked {
    var storage: Google_Rpc_ResourceInfo
    // See https://protobuf.dev/programming-guides/proto3/#any
    static var typeURL: String { "type.googleapis.com/google.rpc.ResourceInfo" }

    init(storage: Google_Rpc_ResourceInfo) {
      self.storage = storage
    }

    /// A name for the type of resource being accessed, e.g. "sql table",
    /// "cloud storage bucket", "file", "Google calendar"; or the type URL
    /// of the resource: e.g. "type.googleapis.com/google.pubsub.v1.Topic".
    public var type: String {
      get { self.storage.resourceType }
      set { self.storage.resourceType = newValue }
    }

    /// The name of the resource being accessed.
    ///
    /// For example, a shared calendar name: "example.com_4fghdhgsrgh@group.calendar.google.com",
    /// if the current error is `permissionDenied`.
    public var name: String {
      get { self.storage.resourceName }
      set { self.storage.resourceName = newValue }
    }

    /// The owner of the resource (optional).
    ///
    /// For example, "user:<owner email>" or "project:<Google developer project
    /// id>".
    public var owner: String {
      get { self.storage.owner }
      set { self.storage.owner = newValue }
    }

    /// Describes what error is encountered when accessing this resource.
    /// For example, updating a cloud project may require the `writer` permission
    /// on the developer console project.
    public var errorDescription: String {
      get { self.storage.description_p }
      set { self.storage.description_p = newValue }
    }

    public init(type: String, name: String, errorDescription: String, owner: String = "") {
      self.storage = .with {
        $0.resourceType = type
        $0.resourceName = name
        $0.owner = owner
        $0.description_p = errorDescription
      }
    }
  }

  /// Provides links to documentation or for performing an out of band action.
  ///
  /// For example, if a quota check failed with an error indicating the calling
  /// project hasn't enabled the accessed service, this can contain a URL pointing
  /// directly to the right place in the developer console to flip the bit.
  public struct Help: Sendable, Hashable, GoogleProtobufAnyPackable {
    /// Describes a URL link.
    public struct Link: Sendable, Hashable {
      /// The URL of the link.
      public var url: String

      /// Describes what the link offers.
      public var linkDescription: String

      public init(url: String, description: String) {
        self.url = url
        self.linkDescription = description
      }

      init(_ storage: Google_Rpc_Help.Link) {
        self.url = storage.url
        self.linkDescription = storage.description_p
      }
    }

    // See https://protobuf.dev/programming-guides/proto3/#any
    internal static var typeURL: String { "type.googleapis.com/google.rpc.Help" }

    internal func pack() throws -> Google_Protobuf_Any {
      let message = Google_Rpc_Help.with {
        $0.links = self.links.map { link in
          .with {
            $0.url = link.url
            $0.description_p = link.linkDescription
          }
        }
      }

      return try .with {
        $0.typeURL = Self.typeURL
        $0.value = try message.serializedBytes()
      }
    }

    init?(unpacking any: Google_Protobuf_Any) throws {
      guard let storage = try any.unpack(Google_Rpc_Help.self) else { return nil }
      self.links = storage.links.map { Link($0) }
    }

    /// URL(s) pointing to additional information on handling the current error.
    public var links: [Link]

    public init(links: [Link]) {
      self.links = links
    }
  }

  /// Provides a localized error message that is safe to return to the user
  /// which can be attached to an RPC error.
  public struct LocalizedMessage: Sendable, Hashable, GoogleProtobufAnyPackable, ProtobufBacked {
    var storage: Google_Rpc_LocalizedMessage
    // See https://protobuf.dev/programming-guides/proto3/#any
    static var typeURL: String { "type.googleapis.com/google.rpc.LocalizedMessage" }

    init(storage: Google_Rpc_LocalizedMessage) {
      self.storage = storage
    }

    /// The locale used following the specification defined at
    /// https://www.rfc-editor.org/rfc/bcp/bcp47.txt.
    ///
    /// Examples are: "en-US", "fr-CH", "es-MX"
    public var locale: String {
      get { self.storage.locale }
      set { self.storage.locale = newValue }
    }

    /// The localized error message in the above locale.
    public var message: String {
      get { self.storage.message }
      set { self.storage.message = newValue }
    }

    public init(locale: String, message: String) {
      self.storage = .with {
        $0.locale = locale
        $0.message = message
      }
    }
  }
}
